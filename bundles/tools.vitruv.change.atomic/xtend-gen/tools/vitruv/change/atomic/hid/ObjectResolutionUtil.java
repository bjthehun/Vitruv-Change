package tools.vitruv.change.atomic.hid;

import com.google.common.base.Preconditions;
import edu.kit.ipd.sdq.activextendannotations.Utility;
import edu.kit.ipd.sdq.commons.util.org.eclipse.emf.ecore.resource.ResourceUtil;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.emf.ecore.util.EcoreUtil;

@Utility
@SuppressWarnings("all")
public final class ObjectResolutionUtil {
  /**
   * Returns a hierarchic URI fragment for the given {@link EObject}. Its use case is to resolve the same object
   * in different instances of the same resource loaded into different resource sets.
   * It is essential that the resources must be in the exact same state, and it is <b>not</b> guaranteed that
   * using the returned fragment objects can always be resolved, but at least it gives the chance to do so whenever
   * the ordinary URI delivered by EMF is not sufficient. So use this method with care!
   * <p>
   * Metamodels may use XMI IDs, which are used by EMF as the URI fragment of objects and generated anew
   * during each load of the same resource. Hence, these URI fragments cannot be used to resolve the same
   * object across different resource sets containing a loaded instance of the same resource.
   * The URI fragment generated by this method depends on the fragment given by {@link EcoreUtil#getRelativeURIFragmentPath}
   * and thus does circumvent the problem of XMI IDs.
   * <p>
   * In consequence, for an object <code>objectInResourceSet1</code> contained in a {@link ResourceSet}
   * <code>resourceSet1</code>, it should be possible to resolve it in another {@link ResourceSet}
   * <code>resourceSet1</code>, even when its resource uses XMI IDs:
   * <pre>
   * <code>
   *    assertTrue(resourceSet1.getEObject(EcoreUtil.getURI(objectInResourceSet1), false))
   *    val objectInResourceSet2 = resourceSet2.getEObject(getHierarchicUriFragment(objectInResourceSet1), false)
   * </code>
   * </pre>
   * 
   * @param object - the {@link EObject} to get a hierarchic URI fragment for
   * @returns a hierarchic URI fragment for the given {@link EObject}
   */
  public static String getHierarchicUriFragment(final EObject object) {
    final Resource resource = object.eResource();
    int rootElementIndex = 0;
    EObject _xifexpression = null;
    int _size = resource.getContents().size();
    boolean _lessEqualsThan = (_size <= 1);
    if (_lessEqualsThan) {
      _xifexpression = ResourceUtil.getFirstRootEObject(object.eResource());
    } else {
      EObject _xblockexpression = null;
      {
        EObject container = object;
        while (((container != null) && ((rootElementIndex = resource.getContents().indexOf(container)) == (-1)))) {
          container = container.eContainer();
        }
        Preconditions.checkState((container != null), "some container of %s must be a root element of its resource", object);
        _xblockexpression = container;
      }
      _xifexpression = _xblockexpression;
    }
    final EObject resourceRoot = _xifexpression;
    final String fragmentPath = EcoreUtil.getRelativeURIFragmentPath(resourceRoot, object);
    boolean _isEmpty = fragmentPath.isEmpty();
    if (_isEmpty) {
      return ("/" + Integer.valueOf(rootElementIndex));
    } else {
      return ((("/" + Integer.valueOf(rootElementIndex)) + "/") + fragmentPath);
    }
  }

  private ObjectResolutionUtil() {
    
  }
}
